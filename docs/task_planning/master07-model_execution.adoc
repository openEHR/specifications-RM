= Task Execution Model

== Overview

The following figure shows the execution related parts of the `rm.task_planning` package. The consists of two parts: the _materialised_ representation, and the _execution history_ part. The former is a partial specification of classes that could be instantiated at Task Plan execution time to track Plan execution, and is provided as a guide to how execution tracking can be done. The latter classes describe the execution history after the fact, in the form of _event records_ that can optionally be stored in the EHR after Task Plan execution has completed.

[.text-center]
.rm.task_planning package - execution model
image::{uml_export_dir}/diagrams/RM-task_planning-execution.svg[id=rm_task_planning_execution, align="center"]

As described in <<Execution Semantics>>, Plan execution traverses three states: `materialised`, `activated` and `terminated`, as follows:

* `materialised` state: at any time after creation of the materialised Plan from its definition form, the following actions are possible:
** Various changes can be made to the materialised structure, as long as they do not violate the constraints on the definition;
** Connection to a notification push-channel must be made for every principal participant and external system mentioned in the Plan definition; these channels do not have to be all different (i.e. multiple parties may be communicated with via a single channel that talks to say a ward screen).
** Advance allocations of Tasks to concrete participants may be made in this phase;
* `activated` state: the materialised Plan is _activated_ at some point in time after creation. 
** This establishes the zero point of the execution clock, and will cause various kinds of notifications to occur as time moves forward.
** The execution system then creates notifications through the various channels to indicate Tasks to be executed for each type of performer.
** Where performers are already allocated, they may commence work and indicate back to the system the state of each Task as it proceeds through its lifecycle (below).
** For Tasks that are not yet allocated, a notification soliciting an acceptance is posted when this is responded to by a user, work begins.
** During the work, Tasks become _available_ (see below) as earlier Tasks are completed or cancelled. When a Task is available to be done, the performer has various options, including doing the work, cancelling the Task as not needed, completing the Task, aborting it, and abandoning the entire Plan.
** As the work proceeds, event records are generated and added to the execution history.
** The Plan remains in the active state until abandoned or completed.
* `terminated` state: A Plan terminates when a path taken through the materialised Task graph terminates, either due to finishing, or due to abandonment at an intermediate Task. 
** The Plan as a whole returns a termination status of success or fail, which may be used to control behaviour if it is part of a handover chain in which a context switch follows termination.
** A final event record is added to the execution history.

During a long-running Task Plan, the principal performer may change. This will usually be the case for Task Plans that run longer than a work shift.

== Materialisation

When a Work Plan is to be executed, it will be materialised. Some user input may be required, e.g. number of repetitions of repeatable sections. The materialised representation consists of:

* A copy of the definition form of the Plan;
* An instance of the Plan using Materialised model instances, i.e. the `M_XXX` classes, representing the concrete executable Tasks, each with a reference back to a definition Task. For Plans with repeatable sections, the Materialised model contains these sections 'unrolled' into as many instances as required by the Plan activator. Thus, more than one `M_TASK` may point to the same generating `TASK` from the definition form.

The structure created will this mirror the structure of the original definition, with extra copies for repeatable sections. That is to say, `M_TASK_GROUP` instances will have `_members_` containing further `M_XX` instances, that mimic the `TASK_GROUP` structures within the Plan definition.

[.tbd]
TBD: Structural modifications

* alter repeating section repeats
* remove decision branches and Tasks whose conditions will never be met

[.tbd]
TBD: Connection setup

[.tbd]
TBD: Allow pre-allocations

== Activation

A materialised Plan is activated when it is ready to be used. Activation 'starts the clock'; accordingly, the `M_TASK_PLAN` attribute `_start_time_` is set to the current time. Execution times in the Plan are converted to absolute clock times, or a form that can be related to clock time.

The materialised form of the detailed structure of the plan may be instantiated fully, or only partially, where convenient. For example, if most of the plan has been completed, and only some steps remain, it may make sense to instantiate only the `M_XX` instances corresponding to those steps. On the other hand, an applicaiton may want to display the details of the whole plan, even when only a small part remains to be executed.


When the structure creation has been completed, the `_lifecycle_state_` attribute of one or more `M_TASK` instances may be set to `available`, or if picking up from a previous session, to other states (i.e. `completed` etc), as appropriate.

At materialisation time, an instance of `EXECUTION_HISTORY` is also created, proving a root point to accumulate Task Plan execution event records.

== Termination

[.tbd]
TBD

== Execution Time Semantics

=== Allocation and re-allocation

Before a materialised Task Plan can be executed, the `_principal_performers_` of its `TASK_GROUPs` must be _allocated_ to real actors. This is done by user(s) authenticating to the Plan execution engine and signing up for specific roles and functions within the Plan. Not all performers are needed at any time, only those implicated in some defined part of the Plan to be executed, e.g. for the current day within a multi-day Plan.

At various moments during the execution of a Plan, a performer may leave and be replaced by another performer, e.g. due to worker shift changeover. This requires a de-allocation of the leaving performer from the Plan and a new allocation of a new actor.

=== Task Lifecycle Model

During execution, each Task is represented by an instance of `M_TASK` that refers back to its `TASK` definition instance. Each Task in the Plan has a lifecycle consisting of various states it may pass through in time. Changes in the lifecycle are recorded in `M_TASK._lifecycle_state_`. The lifecycle is simple, since it only has to take account of the states a Task itself can pass through - states of any order with which the Task may be associated will be visible in the documentation of the Task execution, i.e. separate openEHR `ACTION` or other Entry objects. The states are as follows:

* `initial`: initial pseudo-state, not used in operation;
* `planned`: defined, but not yet available for execution;
* `available`: available for execution, due to previous Tasks having been performed, preconditions being met, and if there is a time specification on the Task, the current time being at or later than the stated time;
* `cancelled` (T): cancelled prior or during execution as not needed for success of the Plan;
* `completed` (T): performed to completion;
* `abandoned` (T): execution was stopped before or after commencement due to completion being impossible.;
* `underway`: indicates that a Task execution has been commenced;
* `suspended`: indicates that a Task execution has been suspended.

In the above, the terminal states are marked with '(T)'. The state machine is shown below.

[.text-center]
.Task lifecycle state machine
image::{uml_export_dir}/diagrams/RM-TaskStateMachine.svg[id=task_state_machine, align="center", width=60%]

A key feature of the state model is that the terminal states determine whether the Plan exeuction continues or not: if the `abandoned` state is entered, it does not.

[.tbd]
ISSUE: in this scheme, if a Task has been started and has to be aborted, but the Plan doesn't need to be abandoned, a transition to cencelled is required. There are thus no distinct state for 'Task aborted (continue)' and 'Task aborted (abandon).

The state machine is primarily designed to allow a stateless view of the actual execution state of a Task. That is to say, the standard pathway is `available` => `completed` or `abandoned` or `cancelled`, which enables a user to indicate the outcome of executing a Task, but not interim states during execution. The pathways through the states `underway` and `suspended` are provided to represent in-execution states if needed, typically for longer-running atomic Tasks.

It may be that one or more Tasks do not evaluate to `available` at runtime when the principal performer wants to treat them as being available. This may happen if the performer wants to execute a Task earlier than scheduled, or decides that an unmet precondition or wait condition does not matter (for example, they may know that it is met, but the Task Plan application may not yet know). Accordingly, a user override can be used, represented by the override pathway from `planned` => `available`.

Since a Task Plan is a hierarchical structure consisting of one or more Task Groups, a way of rolling up Task state is needed. The following algorithm is used to compute the effective lifecycle state of a `M_TASK_GROUP` from the set of states of its members (which may include other `M_TASK_GROUPs`).

[source, java]
--------
//
// Infer the state of a collection whose members have states in sourceStates.
// The order of if/else evaluation determines the correct result.
//
TaskState inferredState (Set<TaskState> sourceStates) {
    
    if (sourceStates.contains(Abandonned))
        return Abandonned;
    else if (sourceStates.contains(Available))
        return Available;
    else if (sourceStates.contains(Planned))
        return Planned;
    else if (sourceStates.contains(Completed))
        return Completed;
    else if (sourceStates.contains(Suspended))
        return Suspended;
    else if (sourceStates.contains(Suspended))
        return Suspended;
    else if (sourceStates.contains(Cancelled))
        return Cancelled;
    else
        return Initial;
}
--------

Since the runtime Task Group is also the top-level structure of the runtime Task Plan, the inferred state of the Plan as a whole is also provided by this algorithm applied to the top-level runtime Task Group.

=== Notifications

Notifications can be specified to be generated at various lifecycle state changes.

[.tbd]
To be continued

=== Context Switching

[.tbd]
TBD: describe context switch for hand-off, external requests etc. The notion of resume_location implies a need to reset Task states for re-entrant processing.

=== Persistence

The run-time instance structure may need to be persisted to enable a partial execution of a long-running Task Plan to be recorded and picked up when later tasks become ready. In theory, this could be within the EHR, but it is recommended that either a specific EHR area be used for this, or that run-time state persistence be implemented outside the EHR proper.

[.tbd]
issue-runtime-persistence: if within the EHR, we could create a new 'pointer' on the EHR object that points to 'task runtime state' data or similar. Is this a useful thing to do?

== Class Descriptions

include::{uml_export_dir}/classes/m_task_plan.adoc[]

include::{uml_export_dir}/classes/m_plan_data_context.adoc[]

include::{uml_export_dir}/classes/m_callback.adoc[]

include::{uml_export_dir}/classes/m_plan_item.adoc[]

include::{uml_export_dir}/classes/m_task_item.adoc[]

include::{uml_export_dir}/classes/m_task_group.adoc[]

include::{uml_export_dir}/classes/m_task.adoc[]

include::{uml_export_dir}/classes/m_decision_group.adoc[]

include::{uml_export_dir}/classes/m_decision_path_group.adoc[]

include::{uml_export_dir}/classes/m_allocation.adoc[]

== Task Plan Execution History

The history of execution events is represented in the runtime instance of `EXECUTION_HISTORY`. This is a history of real world execution events that accumulates over the duration of processing of the Task Plan. Two types of event are used:

* `TASK_EVENT_RECORD`: type representing a change to one consitutent Task. Thus, if the performer cancels a particular Task within the list, a `TASK_EVENT_RECORD` will be added to the history, including Task id, time, and reason; notifications can also be recorded on such events;
* `TASK_PLAN_EVENT_RECORD_`: type representing any kind of execution event not linked to a specific Task, for example 'plan abandonment', 'new principal performer'.

The first type may also include forward references to EHR Entries that were committed as a result of a Task being performed. This facilitates logical indexing of planned and performed work items.

The Execution history will clearly grow and might become quite long for some Task Plan executions. How it may be persisted in various ways. The following possibilities are all compatible with both the model, and typical EHR requirements:

* In the Task Plan application persistence:
** persist the full history, delete or archive once the Task Plan is fully completed;
* In the EHR:
** persist the full history in some or all cases, if useful in the EHR environment (e.g. for teaching);
** persist a partial / filtered version of the history, e.g. retain only _cancel_ and _abort_ events, on the basis that completed Tasks will show up as `ACTIONs` elsewhere in the EHR;
** don't persist any of the history - rely on the workflow application persistence for it during execution, and forget afterward.

This approach cleanly separates the definitional representation of a Task Plan, which should only change if changes to the plan are made, and the execution state, which is built during the work performance.

=== Class Descriptions

include::{uml_export_dir}/classes/task_plan_execution_history.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_plan_event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_notification_record.adoc[leveloffset=+1]

== Cost Tracking

[.tbd]
TBD: describe cost tracking.

=== Class Descriptions

include::{uml_export_dir}/classes/task_costing.adoc[leveloffset=+1]

== Transactional Micro-service

The information structures required to represent planned Tasks and references at runtime are likely to be non-trivial. For this reason, a Micro-service is defined, with a transactional interface that converts transactional calls to correct underlying information structures.

[.tbd]
TBC: 

=== Class Descriptions

include::{uml_export_dir}/classes/task_planning_ms.adoc[leveloffset=+1]

